package com.lifeos.domain.usecase.action

import com.lifeos.domain.model.ActionCompletion
import com.lifeos.domain.repository.ActionRepository
import com.lifeos.domain.util.Result
import kotlinx.coroutines.flow.first
import kotlinx.datetime.Clock
import kotlinx.datetime.TimeZone
import kotlinx.datetime.toLocalDateTime

class CompleteActionUseCase(
    private val actionRepository: ActionRepository
) {
    suspend operator fun invoke(actionId: String): Result<Unit> {
        val now = Clock.System.now()
        
        // 1. Log completion
        val completion = ActionCompletion(
            id = "", // Will be generated by the database
            actionId = actionId,
            completedDate = now.toLocalDateTime(TimeZone.currentSystemDefault()).date,
            completedAt = now
        )
        val completeResult = actionRepository.completeAction(actionId, completion)
        if (completeResult is Result.Error) return completeResult

        // 2. Check if action needs to be deleted (non-recurring) or rescheduled
        val actionResult = actionRepository.getActionById(actionId).first()
        
        if (actionResult is Result.Success && actionResult.data != null) {
            val action = actionResult.data!!
            if (!action.isRecurring) {
                return actionRepository.deleteAction(actionId)
            } else {
                // TODO: Implement rescheduling logic for recurring actions
                // For now, we leave it as is, but in future we would update dueDate
            }
        }
        
        return Result.Success(Unit)
    }
}
